# CODING.md

## Naming
- Discuss naming choices before broad renames.
- Use domain nouns for class names.
- Keep domain names aligned to real-world concepts.
- Keep domain names concise and descriptive.
- Prefer single-word names first; use multi-word names only when extra words are required for clarity.
- Avoid UI-flavoured naming in domain/application layers unless explicitly justified.

## Coding
- Preserve existing author comments.
- Prefer plain-English code over unnecessary indirection.
- For new or generated production code, add concise comments for intent and non-obvious logic.
- For code generated by Codex, add meaningful comments at module, class, and method level (especially private methods and domain logic) that explain what and why.
- For code generated by Codex, also add concise explanatory comments on key non-obvious lines inside methods (for example guards, branch decisions, side-effect calls, and data transforms) so intent and reason stay explicit.
- Do not prefix comments with `Why:`; write direct high-quality comments that clearly explain intent and reason.
- Well-known, proven, widely trusted, and safe third-party libraries are allowed for production use.
- Ask for confirmation before adding a new dependency only when risk, maintenance burden, licensing, or security posture is unclear.
- Ask for confirmation before importing an outside library (gem, npm, pip, external package) only when the choice is not clearly standard or safe for the use case; Ruby standard-library modules are always allowed.
- Codex may use safe tools or libraries for execution work, as long as they are not introduced as codebase dependencies.
- Use tabs for indentation in programming languages, except where tabs are technically restricted.
- Prefer concise one-line code expressions or calls where readability is preserved; use multi-line formatting only when clarity, correctness, or tooling constraints require it.
- Keep spaces around operators (assignment, relational, range, hash rocket, exponent, etc.).
- Keep spaces inside hash braces, block braces, block pipes, and array literals where applicable.
- For method calls with arguments, use spacing like `a_method( p1, p2 )`.
- For arrays, use `[ 1, 2, 3 ]` when non-empty and `[]` when empty.
- Extract logic only when reused, non-trivial, or cross-aggregate.
- Keep domain readability ahead of abstraction.
- Do not trade readability for encapsulation.

## Ruby on Rails Style
- Prefer `do...end` over `{}` for Ruby blocks.
- Avoid `elsif` where a clearer structure is possible.
- Avoid unnecessary parentheses.
- Keep simple, single-use Active Record query chains inline.
- Choose simple Active Record query-chain patterns over complex SQL fragments.
- Favour one-line Rails DSL declarations (for example `belongs_to`, `has_one`, `has_many`, and `enum`) when the statement remains readable.
- Only split these declarations across multiple lines when line length or clarity would otherwise suffer.
- In HTML, ERB, and XML-like templates, keep tag content on one line unless manually edited otherwise.

## File Splitting (Rails-derived)
- Split files by behaviour ownership, not by arbitrary line count.
- Keep one primary class or module responsibility per file.
- Keep file paths aligned with constant namespaces and runtime ownership boundaries.
- Keep entrypoint files thin: wiring, requires/includes, argument parsing, and dispatch only.
- Move substantive behaviour into cohesive modules under a matching subdirectory (for example `relation/*.rb` style in Rails).
- Do not keep pass-through wrapper files that only forward one call and add no policy or behaviour.
- Allow large files only when they remain one cohesive concern with tightly shared context.
- Split a file when it mixes multiple workflows, multiple external integrations, or unrelated helper clusters.
- For command systems, keep discovery and invocation centralised, and keep each real command implementation in a behaviour file with its own private helpers.
